SSO请求流程：

1. 未登陆的用户请求**服务器资源**，被本地服务器的LoginFilter拦截，发现其请求的Session数据没有记录在本地服务器中，请求的url也并没有携带code授权码参数。**于是向第三方登陆服务器跳转**

2. 在用户进行显式的授权（**登陆密码的输入**）后，向第三方登陆服务器发起请求，**第三方服务器校验服务器是否合法**，**再校验用户账号是否无误，无误后，第三方服务器生成tgt，存储在本地，也加入用户的Cookie当中**，**然后生成授权码，内部继续重定向到客户端的资源页面**

3. 此时再次进入客户端的拦截器，客户端仍然没有该请求的Session数据，但这一次携带了CAS颁发的授权码，于是客户端通过远程调用并携带该授权码（Oauth2协议，当登陆服务器与app在一起时，code授权码不对外暴露），向客户端验证该授权码的有效性,验证成功后，向该请求的session中存放SESSION_ACCESS_TOKEN

4. 此时，第三方登陆服务器检验本地是否有该授权码，如有，则取出对应授权用户的信息，并移除该授权码。并在本地生成一个token令牌，记录令牌与用户，授权码之间的关系，还记录登陆凭证tgt与名下令牌的关系，返回给客户端令牌与刷新令牌

5. 客户端调用成功之后，在本地记录该令牌与session（用户请求）（向session中setArtribute，记录过期时间）的关系，![image-20211105111358732](C:\Users\pro\AppData\Roaming\Typora\typora-user-images\image-20211105111358732.png)

   同时再次内部重定向到本地的资源页面

6. 此时请求再再此进入客户端的拦截器，但此时客户端的session中已经有了记录，所以正确的访问到了资源。

图片云盘（p站）
1. 推荐算法
  1. 使用KMP 匹配爱好
2. 缓存淘汰算法
  1. 上述爱好的图片信息都将被缓存至guava的cache中，避免大量查询数据库
3. 分片上传
  1. 使用线程池
  2. 限制用户上传的数量
  3. 上传考虑使用KMP匹配文件名，到指定分类   
4. 根据点击量排序热度

遇到的问题
1. 在某些类，变量使用@Autowired注入，运行时仍然为空？